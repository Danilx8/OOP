Я уже проектировал систему, в которой допустил конфликт таксономии. Попробую её решить:
В систему приходит запрос класса Request, который выглядит так:

class Request
{
    public string action;
    public PassedObject object;
    public string dateAdded;
    public UserDto userDto;
    public Changes new;
    public Changes old;
}

Этот класс примерно повторяет структуру json объекта, приходящего вместе с запросом. 
Ключевой момент, который необходимо выяснить при работе с запросом, с каким объектом мы работаем. 
Всего в системе два типа объекта: задача и комментарий. 
Поскольку у разработчика нет возможности реализовать две разных точки входа для различных объектов, определять тип 
входящего объекта приходится динамически по информации из json объекта.
И от того, какой объект пришёл в систему, меняется всё: контент выходных данных, структура изменений (Changes), 
которые приходят при изменении объекта или его публикации. 
Поскольку в этом примере не подразумевается расширение типов - только расширение функционала над ними - можно создавать
отдельные классы для соответствующих объектов. 
Так из текущей реализации класса Request можно получить следующую систему типов:

class Request
{
    public string action;
    public Comment comment;
    public Task task;
    public string dateAdded;
    public UserDto userDto;
    public CommentChanges newComment;
    public CommentChanges oldComment;
    public TaskChanges newTask;
    public TaskChanges oldTask;
}

Предположим, в систему станет приходить больше значений. К примеру, добавится реакция
В таком случае необходимо будет только добавить новое поле Reaction и логику работы с ним, вызывая его потом во время
формирования объекта Request и непосредственной работы с этим полем, не касаясь остальных полей (как было бы с PassedObject)