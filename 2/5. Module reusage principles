В c# поддерживаются:
1 принцип. Так, например, можно использовать стандартный модуль списка List с возможностью типизировать его элементы любыми типами
2 принцип. В C# такой набор функций, которые активно обращаются друг к другу, можно реализовать с помощью класса
3 принцип. Это верно потому, что в C# можно объединить разные части программы в единый модуль, который образовн из других 
модулей (импортированных или определённых с нуля), и логически выполняет одну задачу. Множество таких модулей формирует 
сборку (Assembly)
4 принцип также применим к C#, потому что благодаря рефлексии и динамиической типизации можно создать модуль, который
будет в рантайме типизироваться с оглядкой на входные данные (и, в случае рефлексии, на другие параметры системы)
5 принцип не применим к модулям, т.к. в c# каждый модуль - это самостоятельная единица, которую непросто будет сравнить
с другой такой же единицей. Механизмами сравнения могут быть хэши и рефлексия, но первая не позволяет найти пересечения,
а вторая слишком дорогая в использовании для таких операций