Делать связи между модулями публичными может быть полезно во многих ситуациях
Следуя 3 приницпу, несколько модулей, объединённых в семейство, могут решать одну задачу, кеоторую нельзя решить одним модулем
В такой ситуации мы можем иметь несколько взаимозаменяемых модулей для одной и той же подзадачи
К примеру, один этап парсинга в серверном приложении может быть представлен в виде самых разных модулей
Также будет полезно знать, используется ли этот модуль где-либо в других модулях. 
С этим знанием поведение программы будет предсказуемее, и можно будет вовремя чинить уязвимости модулей
Также открытые связи между модулями помогают проще проводить дебаг


Для оценки первого принципа можно оценить количество модулей, которые композиционно имеют необходимый интерфейс для взаимодействия с рассматриваемым модулем

Второй принцип довольно сложно оценить, не имея исходного кода модуля. Косвенно этот параметр можно оценить по степени взаимодействия интерфейсов друг с другом. 
Если функция, которая преобразует данные того же типа, что и входные данные другой функции, то можно быть уверенным, что эти функции взаимодействуют
Соответственно, чем больше таких связей по типам, тем больше вероятность, что функций в модулей несколько, и обращаются друг к другу они активнее
Очевидно, при наличии исходного кода, этот принцип легко измерить, отследив вызовы функций.

Третий принцип можно отследить, рекурсивно считая, какие модули реализуют интерфейсы, позволяющие взаимодействовать с одними и теми же модулями
Из полученного древа на первых уровнях можно отследить взаимосвязь модулей и сделать вывод о задаче, которую они могут решать вместе

Четвёртый принцип сложно отследить, не используя рефлексию. Когда код вызывает новый модуль, можно смотреть, к каким типам они относятся

Пятый принцип можно отследить по количеству зависимостей, которые идут вместе с ним. 
Чаще всего, для информации о них даже необязательно иметь исходный код модуля


Я разрабатывал программу, которая получает по вебхуку обновление данных о задаче и затем, в зависимости от характера этих данных, создает новое сообщение в чате, или в тред уже существующего сообщения, пишет ответ, содержащий новые изменения
В проекте 2 сущности: задача и комментарий. Обе из них могут создаваться или обновляться, о чём в систему приходят уведомления
Если сократить текст выше до пары метрик, то выходит, что необходимо проанализировать вызовы функций, типы входных и выходных данных и количество зависимостей у модулей
В таком случае, модуль контроллера входил в семейство модулей с фабриками сущностей и сервисами по формированию сообщений => выполняется третий принцип
При этом, сам модуль контроллера динамически определяет тип пришедших данных в формате JSON и запускает тот воркфлоу, который необходим пришедшим данным
Логгированием и рефлексией можно отследить выполнение этого пункта, что покажет выполнение 1 пункта
В самом коде контроллера, сервисов и фабрик видны вызов функций (методов) других модулей, что демонстрирует выполнение 2 пункта.