1) Наследование вариаций
В задачах выше был пример базового класса, который поддерживал метод Serialize. 
Подобный метод ToString() будет разумно варьировать функционально для различных объектов 
(какие-то поля исключать из сериализации, а каким-то - эксплицитно определять способ сериализации)

В системе типов сотрудников метод авторизации может различаться кардинально в зависимости от важности этой роли
Если для штатных сотрудников хватит логина и пароля, то топ-менеджменту имеет смысл добавлять ключи
Для реализации такого функционала список входных параметров метода Login расширится. Реализация тоже

2) Наследование с конкретизацией
От абстрактнго класса Watch наследуются классы BigBen, HandWatch и SunDial, которые конкретизируют, например, метод Time()

В соревновательной игре с персонажами, каждыый из которых представлен собственным классом существует абстрактный родительский класс Class
От этого класса наследуются классы типа Gunslinger, Sniper, Healer, каждый из которых по-своему конкретизирует, например, метод UltimateAbility()

3) Структурное наследование
В C# есть атрибут Serializable, который позволил разрабам языка не реализовывать методы Serialize и Deserialize прямо в 
классе Object. Такой атрибут есть в стандартной библиотеке, и можно импортировать реализацию этого атрибута из разных библиотек,
за счёт чего сериализовываться классы будут по-разному

Подобный механизм можно реализовать и для связей с базой данных. В таком случае в библиотеках драйверов СУБД можно реализовать
методы типа Get(), Update(), Remove() итп, которые будут преобразовываться в директивы СУБД для любого класса, которому
назначили этот атрибут